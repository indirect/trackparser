global parser
global sec
property pathToBase : 0
if pathToBase is 0 then
	set pathToBase to ((path to "dlib" from user domain as string) & "Music:Scripts:Parser (Song Names).scpt")
end if

set success to false
repeat while not success
	try
		set parser to (load script (pathToBase as alias))
		tell parser to loadPrefs()
		set success to true
	on error
		set pathToBase to (choose file with prompt "Please locate the 'Parser (Song Names)' script" default location (path to "dlib" from user domain)) as string
	end try
end repeat

set res to display dialog "Which Favorites menu would you like to manage - The 'Parser (Song Names)' menu, or the 'Parser (Clipboard)' menu?" buttons {"Cancel", "Clipboard", "Song Names"} default button 3

if button returned of res is "Clipboard" then
	set faves to a reference to parser's pref's histC
	set sec to "C"
else if button returned of res is "Song Names" then
	set faves to a reference to parser's pref's histSN
	set sec to "SN"
end if

--set faves to a reference to parser's pref's histSN
--set favesC to a reference to parser's pref's histC
-- faves = { {pat:.. txt:..}, {pat:.., txt:..}, ..}

-- Make a list
set txtList to {}
repeat with itm in faves
	copy (itm's txt & " (" & itm's pat & ")") to the end of txtList
end repeat

copy "<Spin off into a Separate Script>" to the beginning of txtList

set res to choose from list txtList with prompt "Pick a pattern to modify" OK button name "Modify/Remove" cancel button name "Exit" without multiple selections allowed and empty selection allowed
if res is false then return

to getIndexInList(itm, lst)
	local i
	repeat with i from 1 to length of lst
		if (item i of lst) = itm then
			return i
		end if
	end repeat
	return -1
end getIndexInList
set chosen to item 1 of res

set idx to my getIndexInList(chosen, txtList)

if idx < 0 then error -128

if (idx = 1) then
	my spinOff(faves, items 2 thru (length of txtList) of txtList)
	return
else
	set idx to idx - 1
end if

set itm to item idx of faves
--display dialog (itm)

-- Ask whether they'd like to change the name
set res to display dialog "Enter the new name:" default answer itm's txt buttons {"Cancel", "Delete Item", "Change"} default button 3
--if button returned of res is "Cancel" then error -128

if button returned of res is "Delete Item" then
	if sec is "SN" then
		copy removeFromList(faves, idx) to parser's pref's histSN
	else if sec is "C" then
		copy removeFromList(faves, idx) to parser's pref's histC
	end if
else
	set itm's txt to text returned of res
	
	-- Ask whether they'd like to change the pattern
	set res to display dialog "Enter the new pattern:" default answer itm's pat buttons {"Cancel", "Change"} default button 2
	--if button returned of res is "Cancel" then error -128
	
	set itm's pat to text returned of res
	
	-- Make the changes
	copy itm to item idx of faves
end if
tell parser to savePrefs()


to removeFromList(lst, idx)
	set ret to {}
	repeat with i from 1 to length of lst
		if i ­ idx then
			copy item i of lst to the end of ret
		end if
	end repeat
	return ret
end removeFromList

-- Needs to know which source it takes input from
to spinOff(faves, lst)
	set res to choose from list lst with prompt "Choose a Pattern to Spin off into a Separate Script:" OK button name "Spin Off" cancel button name "Cancel" without multiple selections allowed
	set chosen to item 1 of res
	set idx to my getIndexInList(chosen, lst)
	set itm to item idx of faves
	
	set scpt to my getStandaloneScript(itm's pat, sec)
	
	set pTB to (path to "dlib" from user domain as string) & "Music:Scripts"
	set fileName to choose file name default name itm's txt default location (pTB as alias)
	store script scpt in fileName replacing yes -- the choose file name command asks about overwriting
	
end spinOff

-- Pat is the pattern
-- src is either "SN" or "C"
-- This is pretty long, since it needs to include most of the machinery
-- from the Parser (Song Names) script
-- I wish there were a better way to do the script properties
-- They should really be in the script as text
to getStandaloneScript(thePat, theSrc)
	script scpt
		--
		-- This script was generated by Dan Vanderkam's Track Parser
		--
		-- If you resave this script in the Script Editor, then all
		-- of these properties will be lost, and the script will no
		-- longer work. To get around this, you'll have to coax the compiled
		-- pattern out of the "Parser (Song Names)" script and paste it
		-- in after the cPat property.
		--
		property pat : "(stored as a script property)"
		property cPat : "(stored as a script property)"
		property src : "(stored as a script property)"
		property substQACode : ""
		on run
			my initPattern(cPat)
			
			if src = "SN" then
				
				tell application "Music"
					set sel to selection of front browser window
					set callback to my makeChanges
					set num to length of sel
					repeat with i from 1 to num
						set isong to item i of sel
						set trackName to isong's name
						my applyPattern(trackName, cPat, isong, callback)
						if result is false and i < num then
							if button returned of (display dialog "An error occured matching " & pat & " to '" & trackName & "'. Would you like to continue matching?" buttons {"Stop Now", "Continue Matching"} default button 1) is "Stop Now" then
								error number -128
							end if
						end if
					end repeat
				end tell
				
			else if src = "C" then
				
				tell application "Music"
					set txt to (the clipboard as text)
					set mlines to my split(return, txt)
					
					set callback to my makeChanges
					set sel to selection of front browser window
					set numT to length of sel
					set numL to length of mlines
					set iLine to 0
					
					repeat with iTrack from 1 to numT
						set thisTrack to item iTrack of sel
						set iLine to iLine + 1
						repeat while item iLine of mlines is ""
							set iLine to iLine + 1
						end repeat
						
						set thisLine to item iLine of mlines
						my applyPattern(thisLine, cPat, thisTrack, callback)
						if result is false and iTrack < numT then
							if button returned of (display dialog "An error occured matching " & pattern & " to '" & thisLine & "'. Would you like to continue matching?" buttons {"Stop Now", "Continue Matching"} default button 1) is "Stop Now" then
								error number -128
							end if
						end if
					end repeat
				end tell
				
			end if
		end run
		
		-- Routines hoisted from Parser (Song Names)
		-- This is the minimal set of routines which will run any pattern
		-- Most patterns won't use all of them, so in any given script,
		-- there will be a lot of room for trimming
		
		-- At the moment, this routine just asks questions
		-- before the pattern is applied, so that they aren't
		-- asked for each individiual song.
		to initPattern(pat)
			local ans, q
			if pat's type is "regexsub" then
				set ans to {}
				repeat with q in pat's q
					set res to display dialog q default answer ""
					copy text returned of res to the end of ans
				end repeat
				set substQACode to my GetQACode(ans)
			end if
		end initPattern
		
		
		-- Matches pat to song, applying
		-- the results to theSong
		-- using the dispatcher(field,value,song) routine
		to applyPattern(song, pat, theSong, callback)
			if pat's type is "regex" then return my applyRegex(song, pat, theSong, callback)
			if pat's type is "regexsub" then return my applySubst(song, pat, theSong, callback)
			
			local fldT
			local fldV
			local pos
			local txt
			set fldT to pat's t --item 1 of pat
			set fldV to pat's v --item 2 of pat
			set pos to 1
			set txt to song
			
			-- Set things up for the callback
			script cb
				property fn : callback
			end script
			
			repeat with i from 1 to length of fldV
				set v to item i of fldV
				set t to item i of fldT
				if t = 0 then
					-- Check that the characters match
					if (text 1 thru (length of v) of txt) ­ v then
						display dialog "Song '" & song & "' did not match pattern '" & pattern & Â
							". Expected '" & v & "' but found '" & Â
							(text 1 thru (length of v) of txt) & "'." buttons {"OK"}
						return false
					else
						-- It Matched, so advance our position
						if txt = v then
							txt = ""
						else
							set txt to text (1 + (length of v)) thru -1 of txt
						end if
						--display dialog "Matched '" & v & "' (" & (length of v) & ") => '" & txt & "'"
					end if
				else if t = 1 then
					-- Scan until we hit the next string literal
					if i = length of fldV then
						cb's fn(v, txt, theSong)
						--my dispatcher(v, txt, theSong)
					else
						if (item (i + 1) of fldT) = 1 then
							display dialog "Fields must be separated by strings literals" buttons {"OK"}
							return false
						else
							set nextPos to offset of (item (i + 1) of fldV) in txt
							if nextPos = 0 then
								display dialog "Song '" & song & "' did not match pattern '" & pattern & Â
									". Expected '" & (item (i + 1) of fldV) & "', but it was not found." buttons {"OK"}
								return false
							else
								set itm to text 1 thru (nextPos - 1) of txt
								set txt to text nextPos thru -1 of txt
								cb's fn(v, itm, theSong)
							end if
						end if
					end if
				end if
			end repeat
			return true
		end applyPattern
		
		-- Split txt around delim
		on split(delim, txt)
			local saveD, mlines
			set saveD to AppleScript's text item delimiters
			set AppleScript's text item delimiters to (delim as list)
			set mlines to every text item of txt
			set AppleScript's text item delimiters to saveD
			return mlines
		end split
		
		-- Should double quote |, single quote ' in pat, txt
		on match(ptxt, ppat)
			local scpt, res, txt, pat
			set txt to ptxt
			set pat to ppat
			if txt contains "'" then set txt to escapeApostrophe(txt)
			if pat contains "'" then set pat to escapeApostrophe(pat)
			if txt contains "|" then set txt to escape(txt, {"|"})
			if pat contains "!" then set pat to escape(pat, {"!"})
			
			try
				set scpt to "perl -e '@m = q|" & txt & "| =~ m!" & pat & "!i; print join qq/\\n/, @m'"
				--set scpt to "perl -e \"@m = q|" & txt & "| =~ m|" & pat & "|i; print join qq/\\n/,@m\""
			on error
				return false
			end try
			--set the clipboard to scpt
			set res to do shell script scpt
			if res is "" then return false
			return split(return, res)
		end match
		
		-- run ppat on ptxt
		-- ppat is of the form s/a/b/gi
		-- ppat gets directly thrown into the perl script, so watch out
		-- prefix gets inserted before the pattern to do whatever initialization
		-- is necessary. Typically this is an empty string.
		on subst(ptxt, ppat, pprefix)
			local scpt, res, txt, pat, prefix
			set txt to ptxt
			set pat to ppat
			set prefix to pprefix
			if txt contains "|" then set txt to escape(ptxt, {"|"})
			if txt contains "'" then set txt to escapeApostrophe(txt)
			if pat contains "'" then set pat to escapeApostrophe(pat)
			if prefix contains "'" then set prefix to escapeApostrophe(prefix)
			
			try
				-- Not sure why I did the @m business before
				--set scpt to "perl -e '$x = q|" & txt & "|; @m = $x =~ " & pat & "; print $x, qq/\\n/, join qq/\\n/, @m'"
				set scpt to "perl -e '" & prefix & " $x = q|" & txt & "|; $x =~ " & pat & "; print $x'"
			on error
				return false
			end try
			
			--set the clipboard to scpt
			set res to do shell script scpt
			if res is "" then return false
			--display dialog res
			return split(return, res)
		end subst
		
		-- In the string theText, escapes each element of chars
		-- If a character occurs twice in chars, it is double quoted
		on escape(theText, chars)
			local OldDelims, newText
			set OldDelims to AppleScript's text item delimiters
			set newText to theText
			repeat with c in chars
				set AppleScript's text item delimiters to c
				set newText to text items of newText
				set AppleScript's text item delimiters to ("\\" & c)
				set newText to newText as text
			end repeat
			set AppleScript's text item delimiters to OldDelims
			return newText
		end escape
		
		on escapeApostrophe(txt)
			local OldDelims, newText
			set OldDelims to AppleScript's text item delimiters
			set newText to txt
			set AppleScript's text item delimiters to "'"
			set newText to text items of newText
			set AppleScript's text item delimiters to ("'\\''")
			set newText to newText as text
			set AppleScript's text item delimiters to OldDelims
			return newText
		end escapeApostrophe
		
		on applyRegex(txt, pat, song, callback)
			local matches, types
			set matches to match(txt, pat's p)
			set types to pat's t
			
			if matches = false then
				display dialog "Couldn't match /" & pat's p & "/" & (types as string) & " to '" & txt & "'" buttons {"OK"}
				return false
			end if
			
			-- Set things up for the callback
			script cb
				property fn : callback
			end script
			
			repeat with i from 1 to length of types
				cb's fn(item i of types, item i of matches, song)
			end repeat
			
			return true
		end applyRegex
		
		on applySubst(txt, pat, song, callback)
			-- Ready the input string for the pattern
			local inp, i, res, ans, vals, matches
			set inp to ""
			repeat with i from 1 to length of pat's t --fld in pat's t
				set fld to item i of pat's t
				if i ­ 1 then set inp to inp & return
				set inp to inp & my getField(fld as string, song)
			end repeat
			
			--display dialog "Input: '" & inp & "'"
			set matches to subst(inp, pat's p, substQACode)
			set vals to split(return, matches)
			
			if length of vals is 1 then
				-- Default target is the first source pattern
				set targets to {item 1 of pat's t}
				set vD to 0
			else
				set targets to every character of (item 1 of vals as string)
				--set vals to item 2 thru (length vals) of vals
				set vD to 1
			end if
			
			-- Set things up for the callback
			script cb
				property fn : callback
			end script
			
			-- Always returning true might be better than this
			--try
			repeat with i from 1 to length of targets
				set fld to item i of targets as string
				set val to item (i + vD) of vals
				cb's fn(fld, val, song)
			end repeat
			return true
			--on error e
			--	return false
			--end try
		end applySubst
		
		to GetQACode(ans)
			local perl, varName, i, itm
			set perl to ""
			set varName to "$ans"
			repeat with i from 1 to length of ans
				set itm to item i of ans
				set itm to my escape(itm, {"!"})
				set perl to perl & varName & "[" & (i - 1) & "] = q!" & itm & "!; "
			end repeat
			return perl
		end GetQACode
		
		-- Actually modify the song
		to makeChanges(var, value, song)
			considering case
				tell application "Music"
					tell song as track
						if var = "a" then
							set artist to value
						else if var = "d" then
							set the disc number to value as number
						else if var = "D" then
							set the disc count to value as number
						else if var = "l" then
							set album to value
						else if var = "n" then
							set name to value
						else if var = "t" then
							set the track number to value as number
						else if var = "T" then
							set the track count to value as number
						else if var = "y" then
							set year to value as number
						else if var = "g" then
							set genre to value
						else if var = "r" then
							set grouping to value
						else if var = "p" then
							set played count to value as number
						else if var = "b" then
							set bpm to value as number
						else if var = "C" then
							set composer to value
						else if var = "e" then
							set played date to value
						else if var = "#" then
							set rating to value as number
						else if var = "0" then
							-- Do nothing
						end if
					end tell
				end tell
			end considering
		end makeChanges
		
		-- Return the value of a field as a string
		-- Used in complex multi-source substitutions
		to getField(var, song)
			considering case
				tell application "Music"
					tell song as track
						if var = "a" then
							return artist
						else if var = "d" then
							return disc number as string
						else if var = "f" then
							set f to location
							return name of (info for f)
						else if var = "D" then
							return disc count as string
						else if var = "l" then
							return album
						else if var = "n" then
							return name
						else if var = "t" then
							return track number as string
						else if var = "T" then
							return track count as string
						else if var = "y" then
							return year as string
						else if var = "g" then
							return genre
						else if var = "r" then
							return grouping
						else if var = "p" then
							return played count as string
						else if var = "b" then
							return bpm as string
						else if var = "C" then
							return composer
						else if var = "e" then
							return played date as string
						else if var = "#" then
							return rating as string
						else if var = "0" then
							return "" -- not sure why anyone would use this
						end if
					end tell
				end tell
			end considering
		end getField
		
	end script
	
	set scpt's pat to thePat
	set scpt's cPat to parser's compilePattern(thePat)
	set scpt's src to theSrc
	
	return scpt
end getStandaloneScript